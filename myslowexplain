#!/usr/bin/env python

import os
import sys
import re
import signal
from optparse import OptionParser

signal.signal(signal.SIGINT,  signal.SIG_DFL)
signal.signal(signal.SIGTERM, signal.SIG_DFL)
signal.signal(signal.SIGPIPE, signal.SIG_DFL)
 
cnt = {}
cnt['Total'] = 0

try:
  import MySQLdb  # MySQL-python
except ImportError:
  try:
    import pymysql as MySQLdb  # PyMySQL
  except ImportError:
    print "Please install MySQLdb or PyMySQL"
    sys.exit(1)

def build_option_parser():
  parser = OptionParser(add_help_option=False, usage="usage: %prog [options] database")
  parser.add_option('-m',         dest='sqlmode', default='select',                    help="select|update|delete (default: select)")
  parser.add_option('-s',         dest='time',                                         help="Start Time(ex: '2012-07-28 03:00:00')")
  parser.add_option('-l',         dest='last',    default='10',                        help="Last Time [MINUTE] (default: 10)")
  parser.add_option('-t',         dest='type',                                         help="Type  (ex: ALL,index default: none)")
  parser.add_option('-e',         dest='extra',                                        help="Extra (ex: 'filesort,temporary' default: None)")
  parser.add_option('-h',         dest='host',    default='127.0.0.1',                 help="(default: 127.0.0.1)", )
  parser.add_option('-P',         dest='port',    default=3306,                        help="(default: 3306)",      )
  parser.add_option('-u',         dest='user',    default='root',                      help="(default: root)",      )
  parser.add_option('-p',         dest='password',                                     help='password')
  parser.add_option('-S',         dest='socket',                                       help='unix domain socket')
  parser.add_option('--no-where', dest='where',   default=True,  action='store_false', help='Do not use a WHERE')
  parser.add_option('--help',     dest='help',                   action="store_true",  help='show this message')
  return parser

def printexplain(exp):
  print "---------------------------------------------------"
  print "%14s: %s" % ("id",            exp['id'])
  print "%14s: %s" % ("select_type",   exp['select_type'])
  print "%14s: %s" % ("type",          exp['type'])
  print "%14s: %s" % ("Extra",         exp['Extra'])
  print "%14s: %s" % ("table",         exp['table'])
  print "%14s: %s" % ("possible_keys", exp['possible_keys'])
  print "%14s: %s" % ("key",           exp['key'])
  print "%14s: %s" % ("key_len",       exp['key_len'])
  print "%14s: %s" % ("rows",          exp['rows'])
  print "%14s: %s" % ("ref",           exp['ref'])

def conv_selectsql(sql):
  if re.search(r'^SELECT ', sql, re.IGNORECASE):
    return sql

  r = re.search(r'^UPDATE (\S+) SET .+ WHERE (.+)$', sql, re.IGNORECASE)
  if r:
    sql = "SELECT * FROM %s WHERE %s" % r.groups()
    return sql

  r = re.search(r'^DELETE FROM (\S+) WHERE (.+)$', sql, re.IGNORECASE)
  if r:
    sql = "SELECT * FROM %s WHERE %s" % r.groups()
    return sql

  return ""

def view_sql(sql):
  print "==================================================="
  print sql

def view_explain(p, sql, res):
  global cnt
  if not cnt.has_key(p):
    cnt[p] = 0
  cnt[p] += 1
  view_sql(sql)
  for exp in res: 
    printexplain(exp)
  
def do_explain(cur, select_sql, typ, ext, sql):
  v = False
  explain_sql = "explain %s" % select_sql
  cur.execute(explain_sql)
  res = cur.fetchall()
  for exp in res:
    if exp['possible_keys'] is None:
      v = True
    else:
      for t in typ:
        if exp['type'] == t or t == '%':
          v = True
          break
      for e in ext:
        if exp['Extra'].find("Using %s" % e) != -1:
          v = True
          break
    if v:
      view_explain(exp['type'], sql, res)
      break

def fetchexplain(res, cur, typ, ext):
  row = res.fetch_row(1, 1)
  if not row:
    return False
  select_sql = conv_selectsql(row[0]['sql_text'])
  sql = " last: %s\ncount: %d\n%s" % (row[0]['start_time'], row[0]['count'], row[0]['sql_text'])
  if select_sql == "":
    view_sql(sql)
  else:
    if select_sql != row[0]['sql_text']:
      sql += "\n" + select_sql
    do_explain(cur, select_sql, typ, ext, sql)
  return True

def main():
  global cnt
  parser = build_option_parser()
  opts, args = parser.parse_args()

  if opts.help:
    parser.print_help()
    return

  if len(args) == 0:
    parser.print_help()
    return

  ext = {}
  typ = {}
  cnf = {}
  cnf['host'] = opts.host
  cnf['user'] = opts.user
  if opts.extra:
    ext = opts.extra.split(",")
  if opts.password:
    cnf['passwd'] = opts.password
  if opts.socket:
    cnf['host'] = 'localhost'
    cnf['unix_socket'] = opts.socket
  else:
    cnf['port'] = opts.port
  if opts.type:
    typ = opts.type.split(",")
    for t in typ:
      cnt[t] = 0

  span = ''
  if opts.last:
    span = "and start_time>(NOW() - INTERVAL %s MINUTE)" % opts.last
  if opts.time:
    span = "and start_time>'%s'" % opts.time

  sql = "SELECT sql_text, max(start_time) as start_time, count(*) as count FROM mysql.slow_log "
  if opts.where:
    sql += "WHERE db='%s' and sql_text like '%s %% WHERE %%' %s GROUP BY sql_text ORDER BY count DESC"
  else:
    sql += "WHERE db='%s' and sql_text like '%s %%' %s GROUP BY sql_text ORDER BY count DESC"

  if opts.sqlmode == 'select':
    sqlmode = "SELECT"
  elif opts.sqlmode == 'update':
    sqlmode = "UPDATE"
  elif opts.sqlmode == 'delete':
    sqlmode = "DELETE"
  else:
    parser.print_help()
    return
  sql = sql % (args[0], sqlmode, span)

  con = {}
  con[0] = MySQLdb.connect(**cnf)
  cnf['db'] = args[0]
  con[1] = MySQLdb.connect(**cnf)
  cur = con[1].cursor(MySQLdb.cursors.DictCursor)

  print "==================================================="
  print "%s" % sql
  con[0].query(sql)
  res = con[0].use_result()
  while(fetchexplain(res, cur, typ, ext)):
    cnt['Total'] += 1
  print "==================================================="
  for t in cnt:
    if t != 'Total' and cnt[t] > 0:
      print "%5s: %6d rows" % (t, cnt[t])
  print "Total: %6d rows" % cnt['Total']

if __name__ == '__main__':
    main()

